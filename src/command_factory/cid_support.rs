// Copyright (c) 2025 - Cowboy AI, LLC.

//! CID Support for Command Factory
//!
//! This module provides content-addressed identity (CID) generation for commands.
//! CIDs are used for:
//!
//! - **Content Verification**: Same content = same CID
//! - **Deduplication**: Identical commands can be detected
//! - **NATS JetStream**: Message deduplication using CID as message ID
//! - **Persistence**: Content-addressed storage in IPLD
//!
//! ## CID Generation
//!
//! CIDs are generated by serializing the command payload to JSON and hashing:
//!
//! ```text
//! Command → serde_json::to_vec() → blake3::hash() → CID
//! ```
//!
//! ## Usage
//!
//! ```rust,ignore
//! use crate::command_factory::cid_support::{CommandWithCid, generate_command_cid};
//!
//! let command = create_person_command(&form, org_id, correlation_id)?;
//! let cid = generate_command_cid(&command)?;
//!
//! // Or use the wrapper
//! let cmd_with_cid = CommandWithCid::new(command);
//! println!("Command CID: {}", cmd_with_cid.cid());
//! ```

use cim_domain::cid::{generate_cid, ContentType, DomainCid};
use serde::Serialize;

/// A command paired with its content-addressed identity
#[derive(Debug, Clone)]
pub struct CommandWithCid<C> {
    /// The command payload
    pub command: C,
    /// Content-addressed identity of the command
    pub cid: DomainCid,
}

impl<C: Serialize> CommandWithCid<C> {
    /// Create a new CommandWithCid by generating CID from command
    pub fn new(command: C) -> Result<Self, String> {
        let cid = generate_command_cid(&command)?;
        Ok(Self { command, cid })
    }

    /// Get the CID as a string (for NATS message ID, etc.)
    pub fn cid_string(&self) -> String {
        self.cid.to_string()
    }

    /// Get reference to the command
    pub fn command(&self) -> &C {
        &self.command
    }

    /// Get reference to the CID
    pub fn cid(&self) -> &DomainCid {
        &self.cid
    }

    /// Consume and return the command
    pub fn into_command(self) -> C {
        self.command
    }

    /// Consume and return both parts
    pub fn into_parts(self) -> (C, DomainCid) {
        (self.command, self.cid)
    }
}

/// Generate a CID for any serializable command
///
/// Uses Blake3 hashing with JSON serialization for deterministic CID generation.
/// The same command will always produce the same CID.
pub fn generate_command_cid<C: Serialize>(command: &C) -> Result<DomainCid, String> {
    generate_cid(command, ContentType::Event)
}

/// Trait for commands that can have CIDs generated
pub trait ContentAddressable: Serialize + Sized {
    /// Generate a CID for this command
    fn content_id(&self) -> Result<DomainCid, String> {
        generate_command_cid(self)
    }

    /// Wrap this command with its CID
    fn with_cid(self) -> Result<CommandWithCid<Self>, String> {
        CommandWithCid::new(self)
    }
}

// Blanket implementation for all serializable types
impl<T: Serialize + Sized> ContentAddressable for T {}

/// Verify that two commands have the same content
///
/// Commands with identical serialized content will have the same CID.
pub fn commands_equal<C: Serialize>(cmd1: &C, cmd2: &C) -> Result<bool, String> {
    let cid1 = generate_command_cid(cmd1)?;
    let cid2 = generate_command_cid(cmd2)?;
    Ok(cid1 == cid2)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::commands::organization::CreatePerson;
    use chrono::Utc;
    use uuid::Uuid;

    fn make_test_command() -> CreatePerson {
        CreatePerson {
            command_id: Uuid::parse_str("019447d8-1234-7000-8000-000000000001").unwrap(),
            person_id: Uuid::parse_str("019447d8-1234-7000-8000-000000000002").unwrap(),
            name: "Test Person".to_string(),
            email: "test@example.com".to_string(),
            title: None,
            department: None,
            organization_id: None,
            correlation_id: Uuid::parse_str("019447d8-1234-7000-8000-000000000003").unwrap(),
            causation_id: None,
            timestamp: chrono::DateTime::parse_from_rfc3339("2026-01-07T12:00:00Z")
                .unwrap()
                .with_timezone(&Utc),
        }
    }

    #[test]
    fn test_generate_command_cid() {
        let cmd = make_test_command();
        let cid = generate_command_cid(&cmd);

        assert!(cid.is_ok());
        let cid = cid.unwrap();
        assert!(!cid.to_string().is_empty());
    }

    #[test]
    fn test_same_command_same_cid() {
        let cmd1 = make_test_command();
        let cmd2 = make_test_command();

        let cid1 = generate_command_cid(&cmd1).unwrap();
        let cid2 = generate_command_cid(&cmd2).unwrap();

        assert_eq!(cid1, cid2);
    }

    #[test]
    fn test_different_command_different_cid() {
        let cmd1 = make_test_command();
        let mut cmd2 = make_test_command();
        cmd2.name = "Different Name".to_string();

        let cid1 = generate_command_cid(&cmd1).unwrap();
        let cid2 = generate_command_cid(&cmd2).unwrap();

        assert_ne!(cid1, cid2);
    }

    #[test]
    fn test_command_with_cid() {
        let cmd = make_test_command();
        let cmd_with_cid = CommandWithCid::new(cmd).unwrap();

        assert_eq!(cmd_with_cid.command().name, "Test Person");
        assert!(!cmd_with_cid.cid_string().is_empty());
    }

    #[test]
    fn test_content_addressable_trait() {
        let cmd = make_test_command();

        // Use trait method
        let cid = cmd.content_id().unwrap();
        assert!(!cid.to_string().is_empty());

        // Use with_cid
        let cmd_with_cid = cmd.with_cid().unwrap();
        assert_eq!(cmd_with_cid.cid().to_string(), cid.to_string());
    }

    #[test]
    fn test_commands_equal() {
        let cmd1 = make_test_command();
        let cmd2 = make_test_command();
        let mut cmd3 = make_test_command();
        cmd3.email = "different@example.com".to_string();

        assert!(commands_equal(&cmd1, &cmd2).unwrap());
        assert!(!commands_equal(&cmd1, &cmd3).unwrap());
    }

    #[test]
    fn test_into_parts() {
        let cmd = make_test_command();
        let original_name = cmd.name.clone();
        let cmd_with_cid = CommandWithCid::new(cmd).unwrap();

        let (command, cid) = cmd_with_cid.into_parts();
        assert_eq!(command.name, original_name);
        assert!(!cid.to_string().is_empty());
    }
}
